package replica

import (
	"context"
	"fmt"
	"github.com/relab/hotstuff"
	"github.com/relab/hotstuff/consensus"
	"github.com/relab/hotstuff/internal/proto/clientpb"
	"github.com/relab/hotstuff/internal/proto/hotstuffpb"
	"google.golang.org/protobuf/proto"
	"sync"
)

type MultiChain struct {
	mut sync.Mutex //Mutex

	ChainPool map[hotstuff.ID]([]consensus.Batch) //multichain

	ChainPoolTip   map[hotstuff.ID]map[uint32]int32 //Record the latest altitude received by other nodes
	PackagedHeight map[hotstuff.ID]int32            //Record the height to which each batch chain has been packaged

	MyGeneratedHeight int32       //The latest height of the batch generated by the current node
	NodeID            hotstuff.ID //Node id
	ReplicaNum        int         //the number of replica
	CanUpdateMyTip    bool

	marshaler   proto.MarshalOptions
	unmarshaler proto.UnmarshalOptions
}

func newMultiChain(id hotstuff.ID) (multichain *MultiChain) {
	multichain = &MultiChain{
		ChainPool: make(map[hotstuff.ID]([]consensus.Batch)),

		ChainPoolTip:   make(map[hotstuff.ID]map[uint32]int32),
		PackagedHeight: make(map[hotstuff.ID]int32),

		MyGeneratedHeight: 0,
		NodeID:            id,
		ReplicaNum:        4,
		CanUpdateMyTip:    false,

		marshaler:   proto.MarshalOptions{Deterministic: true},
		unmarshaler: proto.UnmarshalOptions{DiscardUnknown: true},
	}

	multichain.PackagedHeight[id] = 0
	return multichain
}

func (c *MultiChain) Add(id hotstuff.ID, b *consensus.Batch) {
	c.mut.Lock()

	if _, ok := c.PackagedHeight[id]; !ok {
		c.PackagedHeight[id] = 0
	}

	if b.Cmd != "" {
		c.ChainPool[id] = append(c.ChainPool[id], *b)
	}

	c.ChainPoolTip[id] = b.ChainPoolTip

	if id != c.NodeID {
		c.CanUpdateMyTip = true
	} else {
		c.CanUpdateMyTip = false
		//c.GetCommandsfrombatch(b)
	}

	c.mut.Unlock()
}

func (c *MultiChain) deleteByHash(h consensus.Hash) {
	c.mut.Lock()
	for key, value := range c.ChainPool {
		for id, batch := range value {
			if batch.Hash == h {
				c.ChainPool[key] = c.ChainPool[key][id+1:]
				break
			}
		}
	}
	c.mut.Unlock()
}

func (c *MultiChain) packBatch(ctx context.Context, cache *cmdCache) (batch consensus.Batch, ok bool) {
	cmd, ok := cache.Get(ctx)
	if (!ok) && (c.CanUpdateMyTip) {
		return batch, false
	}
	var genesisHash [32]byte

	c.mut.Lock()

	if ok {
		c.MyGeneratedHeight = c.MyGeneratedHeight + 1
	}
	c.CanUpdateMyTip = false

	if len(c.ChainPool[c.NodeID]) == 0 {
		b := consensus.NewBatch(genesisHash, c.NodeID, cmd, c.MyGeneratedHeight, c.GetMyChainPoolTip())
		batch = *b
	} else {
		b := consensus.NewBatch(c.ChainPool[c.NodeID][len(c.ChainPool[c.NodeID])-1].Hash, c.NodeID, cmd, c.MyGeneratedHeight, c.GetMyChainPoolTip())
		batch = *b
	}
	c.mut.Unlock()
	return batch, true
}
func (c *MultiChain) GetMyChainPoolTip() map[uint32]int32 {
	mytip := make(map[uint32]int32)
	for i := 1; i <= c.ReplicaNum; i++ {
		poollen := len(c.ChainPool[hotstuff.ID(i)])
		if poollen <= 0 {
			mytip[uint32(i)] = -1
		} else {
			mytip[uint32(i)] = int32(c.ChainPool[hotstuff.ID(i)][len(c.ChainPool[hotstuff.ID(i)])-1].BatchID)
		}
	}
	return mytip
}

func (c *MultiChain) PackList() (batchlist consensus.BatchList, ok bool) {
	c.mut.Lock()

	totoal_num := int(0)
	b := new(hotstuffpb.BatchList)
	quorum := c.ReplicaNum
	usebatchhash := false
	for i := 1; i <= c.ReplicaNum; i++ {

		batchLen := len(c.ChainPool[hotstuff.ID(i)])
		if batchLen <= 0 {
			continue
		}
		startHeight := c.PackagedHeight[hotstuff.ID(i)] + 1
		endHeight := c.ChainPool[hotstuff.ID(i)][batchLen-1].BatchID
		usebatchhash = false
		if endHeight >= startHeight {
			nNotFallBehind := 0
			for j := 1; j <= c.ReplicaNum; j++ {
				temptip := c.ChainPoolTip[hotstuff.ID(j)][uint32(i)]
				if temptip <= 0 || temptip <= startHeight {
					continue
				}
				nNotFallBehind = nNotFallBehind + 1
				if temptip < endHeight {
					endHeight = temptip
				}
			}
			if nNotFallBehind >= quorum {
				usebatchhash = true
			} else {
				endHeight = startHeight
			}
			temp := hotstuffpb.BatchListitem{StartHeight: startHeight, EndHeight: endHeight, NodeID: uint32(i), UseBatchHash: usebatchhash}
			b.BatchListitems = append(b.BatchListitems, &temp)
		}
	}
	c.mut.Unlock()
	totoal_num = len(b.BatchListitems) * 16
	fmt.Println("block commands:", totoal_num)
	if len(b.BatchListitems) <= 0 {
		//fmt.Println(c.NodeID, " No packlist")
		return "", false
	}
	p, err := c.marshaler.Marshal(b)
	if err != nil {
		return "", false
	}
	batchlist = consensus.BatchList(p)
	return batchlist, true
}

func (c *MultiChain) GetCommands(list consensus.BatchList) (cmds []*clientpb.Command) {

	batchtest := new(hotstuffpb.BatchList)
	err := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(list), batchtest)
	if err == nil {
		for _, item := range batchtest.GetBatchListitems() {
			for i := item.StartHeight; i <= item.EndHeight; i++ {
				cmdtest := new(clientpb.Batch)
				err1 := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(c.ChainPool[hotstuff.ID(item.NodeID)][i].Cmd), cmdtest)
				if err1 == nil {
					for _, cmd := range cmdtest.GetCommands() {
						cmds = append(cmds, cmd)
					}
				}
			}

		}
	}
	return cmds
}

func (c *MultiChain) GetCommandsfrombatch(batch *consensus.Batch) (cmds []*clientpb.Command) {

	batchtest := new(clientpb.Batch)
	err := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(batch.Cmd), batchtest)
	if err == nil {
		for _, cmd := range batchtest.GetCommands() {
			fmt.Println("--Batch Information Nodeid: ", batch.NodeID, " Batchid: ", batch.BatchID, " cmd.clientid: ", cmd.ClientID, " cmd.sequence: ", cmd.SequenceNumber)
		}
	}
	return cmds
}
func (c *MultiChain) GetCmd(list consensus.BatchList, cmdType bool) (cmd consensus.Command, ok bool) {

	if list == " " {
		return "", false
	}
	batchtest := new(hotstuffpb.BatchList)
	cmds := new(clientpb.Batch)
	err := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(list), batchtest)

	if err == nil {
		c.mut.Lock()
		for _, item := range batchtest.GetBatchListitems() {
			for i := item.StartHeight - 1; i < item.EndHeight; i++ {
				if item.UseBatchHash != cmdType {
					continue
				}
				cmdtest := new(clientpb.Batch)
				err1 := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(c.ChainPool[hotstuff.ID(item.NodeID)][i].Cmd), cmdtest)
				if err1 == nil {
					for _, cmd := range cmdtest.GetCommands() {
						cmds.Commands = append(cmds.Commands, cmd)
					}
				}
			}
		}
		c.mut.Unlock()
	} else {
		return "", false
	}

	b, err := c.marshaler.Marshal(cmds)
	cmd = consensus.Command(b)
	return cmd, true
}

func (c *MultiChain) UpdatePackagedHeight(list consensus.BatchList) {

	batchtest := new(hotstuffpb.BatchList)
	c.mut.Lock()
	err := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(list), batchtest)
	if err == nil {
		for _, item := range batchtest.GetBatchListitems() {
			if item.EndHeight > c.PackagedHeight[hotstuff.ID(item.NodeID)] {
				c.PackagedHeight[hotstuff.ID(item.NodeID)] = item.EndHeight
			}
		}
	}
	c.mut.Unlock()
}
func (c *MultiChain) GetBatchItem(list consensus.BatchList) {

	batchtest := new(hotstuffpb.BatchList)
	//flag := true
	//last := int32(-1)
	err := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(list), batchtest)
	if err == nil {
		for _, item := range batchtest.GetBatchListitems() {
			fmt.Println("Node id:", item.NodeID, " --StartHeight:", item.StartHeight, " --EndHeight:", item.EndHeight, " --usebatchhash:", item.UseBatchHash)
			//cmdtest := new(clientpb.Batch)
			for i := item.StartHeight - 1; i < item.EndHeight; i++ {
				if i+1 != c.ChainPool[hotstuff.ID(item.NodeID)][i].BatchID {
					fmt.Println("should be:", i+1, " real value:", c.ChainPool[hotstuff.ID(item.NodeID)][i].BatchID)
				}
				//fmt.Println("should be:", i+1, " real value:", c.ChainPool[hotstuff.ID(item.NodeID)][i].BatchID)
				//err1 := proto.UnmarshalOptions{AllowPartial: true}.Unmarshal([]byte(c.ChainPool[hotstuff.ID(item.NodeID)][i].Cmd), cmdtest)
				//if err1 == nil {
				//	for _, cmd := range cmdtest.GetCommands() {
				//		fmt.Println("-- client id:", cmd.ClientID, " --sequence number:", cmd.SequenceNumber)
				//	}
				//}
				//if last == -1 {
				//	last = item.EndHeight
				//} else {
				//	if last != item.EndHeight {
				//		flag = false
				//	}
				//}
			}
		}
	}
	//if !flag {
	//	fmt.Println("has old command", last)
	//}
}
